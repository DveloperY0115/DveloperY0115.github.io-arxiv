---
layout: post
title: "Summary of 'PhySG'"
subtitle: "PhySG: Inverse Rendering with Spherical Gaussians for Physics-based Material Editing and Relighting (CVPR 2021)"
background: '/assets/post-images/PhySG/PhySG_overview.png'
---

# Motivation

- Neural rendering methods gain huge attention due to their success in various inverse graphics tasks - geometry reconstruction, novel view synthesis, etc.
- However, **these methods do not factorize appearance into lighting and materials**, thus **it's impossible to do material editing or relighting in physically plausible ways**.
- Besides, typical multi-view inverse rendering methods tackle the problems in constrained settings - assuming varying illumination across input images, capturing objects on a turnable with a fixed camera, etc.

# Key Contributions

- An entire framework including a fully differentiable renderer which can reconstruct geometry, materials, and illumination from scratch from a set of RGB input images.
- **Specular BRDFs and environmental illumination are represented using mixtures of spherical Gaussians. → This helps solving rendering equation (light transport), the crucial part of physically-based rendering**
- Geometry is represented as a SDF parametrized as a MLP.
- Works well on scenes with challenging non-Lambertian reflectance under natural, static illumination.
- Not only synthesizing novel viewpoints, **PhySG can also perform physically-intuitive appearance editing by modifying material or lighting (= relighting).**

---

# TL;DR

<img class="img-fluid" src="/assets/post-images/PhySG/PhySG_overview.png">
<span class="caption text-muted">Figure 1. <b>PhySG overview</b>. PhySG jointly predicts geometry (represented as SDF parametrized as neural network), BRDF and Envmap (both represented as spherical Gaussian) and enables physically-intuitve appearance editing.</span>

This paper proposes **PhySG**, an end-to-end physically-based differentiable rendering pipeline to **jointly estimate lighting, material, geometry and surface normals** from posed multi-view images of specular objects.

PhySG represents scene components as:

- **Signed distance functions** (SDF) for shapes (geometry)
- **Spherical Gaussians** as approximations of lighting and specular BRDFs → Efficient evaluation of light transport

# Background

## Neural rendering

There are multiple approaches for parametrizing scene representations as neural networks. For example, NeRF represents scenes as volumetric opacity fields, other methods such as DVR and IDR regard scenes as surfaces. One common idea they share is that, scenes are represented by a single MLP that takes a 3D point (and possibly view direction) and outputs a color. **This means that all these methods treats objects (more specifically the surface points of them) as light sources**, emitting radiance to the entire space. **→ Physics-based relighting and material editing...? Nope.**

Other approaches learn an *appearance space* from Internet photos of landmarks captured under diverse lighting, but these are not physically-based and hard to apply new lighting conditions.

What makes PhySG stand out among these competitors is that it **models appearance via the physical rendering equation**. This approach can solve inverse rendering problems involving specular or glossy objects under static lighting, and allow us to modify lighting and materials in physically-making-sense manner.

## Material and environment estimation

### Material estimation

Traditional approach for estimating material properties is to capture scenes under varying illumination. Materials are exposed to various illumination conditions - varying relative position between light source and the material, different kind of light sources, etc - and observed to capture their behavior under different situations. **→ SV-BRDFs**

### Environment estimation

To infer the environment from multi-view images, what prior works did are:

- Factorize scene appearance into diffuse image and surface reflectance map given high-quality geometry from RGBD sensors **→ Entangles the material and lighting! Not relightable!**
- Model lighting as surface emissions, and use Monte Carlo differentiable renderer to jointly estimate material properties and surface emissions from multi-view images *conditioned on* scanned geometry and object segmentation masks.
- Predict illumination, materials and shape from a single image via learning-based priors.
- Estimating BRDF and lighting via deconvolution given known geometry.

In contrast, **PhySG aim to jointly estimate the material and environment, together with geometry and surface normals, only from multi-view 2D images captured under unknown static natural illumination**.

## Joint shape and appearance refinement

Also, there are many prior works associated with this task:

- **Given the initial geometry and appearance cpatured by RGBD sensors**, jointly refine geometry and appearance by assuming Lambertian BRDF and incorporating shading cues. In this approach, a lighting model is pre-computed based on spherical harmonics, then remains unchanged while optimizing the shape and diffuse albedo. As a geometric representation, voxelized SDFs are adopted. (Maier et al., Zollhofer et al.)
- On the other hand, **another approach assumes known illumination** and exploits reflectance cues to refine geometry computed via visual hulls.

Compared to these works, **PhySG does not require scanned geometry or a known environment map (lighting)**. The framework predicts material and parameters involving in lighting, as well as geometry and surface normal simultaneously, end-to-end. 

## The rendering equation

The rendering equation proposed by Kajiya et al. is based on the physical law of energy conservation.

Let's say there is a surface point $\textbf{x}$ with surface normal $\textbf{n}$.

Also, suppose $L_{i} (\boldsymbol{\omega}\_{i}; \textbf{x})$ is the incident light intensity at location $\textbf{x}$ along the direction $\boldsymbol{\omega}_{i}$.

And bidirectional reflectance distribution function (BRDF) $ f_{r} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}\_{i}; \textbf{x}) $ is the reflectance coefficient of the material at location $\textbf{x}$ for incident light direction $ \boldsymbol{\omega}\_{i} $ and viewing direction $ \boldsymbol{\omega}\_{o} $.

Then the observed light intensity $ L_{o} (\boldsymbol{\omega}\_{o}; \textbf{x}) $ is an integral over the hemisphere $ \Omega = \{ \boldsymbol{\omega}\_{i} : \boldsymbol{\omega}_{i} \cdot \textbf{n} > 0\} $:

$$ L_{o} (\boldsymbol{\omega}\_{o}; \textbf{x}) = \int_{\Omega} L_{i} (\boldsymbol{\omega}\_{i}) f_{r} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}\_{i}; \textbf{x}) (\boldsymbol{\omega}\_{i} \cdot \textbf{n})d \boldsymbol{\omega}_{i} $$

One remark here is that the BRDF $ f_{r} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}\_{i}; \textbf{x}) $ is a function of viewing direction $ \boldsymbol{\omega}\_{o} $ and models view-dependent effects such as specularity. That is, an appearance of a material can differ depending on the viewpoint where it is seen.

# Method

<img class="img-fluid" src="/assets/post-images/PhySG/PhySG_overview.png">
<span class="caption text-muted">Figure 2. <b>Overview of PhySG inverse rendering pipeline</b>.</span>

PhySG pipeline has three major components:

1. **Geometry modeling**
2. **Appearance modeling**
3. **Forward rendering**

All components are designed to be differentiable, so the whole pipeline, formed by jointly connecting these three, is fully differentiable thus can be optimized end-to-end.

## Geometry modeling

Inspired by recent success, signed distance functions (SDFs) are used for the geometric representation of PhySG.

In fact, SDFs have really nice properties that makes it suitable for neural scene representation.

1. **Supports ray tracing via sphere tracing**
2. **Differentiable**
3. Automatically satisfies the constraint between shape and surface normal → **normal can be computed by calculating the gradient of SDF**

As in many other research papers, SDFs are represented as MLPs (rather than voxel grids) for memory efficiency and continuous, infinite resolution.

More rigorously, let $S(\textbf{x}; \Theta)$ be our SDF, where $\textbf{x}$ is a 3D point and $\Theta$ are the MLP weights. The MLP used for parametrizing SDF in **PhySG consists of 8 nonlinear layers of width 512, with a skip connection at $4^{th}$ layer**.

Similar to NeRF, in order to express high-frequency geometric detail, **positional encoding with 6 frequency components** is used to encode the location of a 3D point. 

While occupancy fields can serve the same purpose, but they are typically much slower during ray tracing, because it requires root-finding to locate the surface. More concretely, it requires over 100 MLP evaluations per cast ray for occupancy fields, whereas **SDFs only need less than 10 MLP evaluations per ray with sphere tracing method**.

To render the pixel color for a camera ray, the intersection where the casted ray meets the SDF must be determined. Then *"how can we efficiently find such intersection with SDF?"*:

1. Start from the ray's intersection with the object bounding box
2. March along the ray via sphere tracing (step size is the signed distance at the current location). Repeat this until reaching the surface.
3. After the surface point $\textbf{x}$ is found, then the surface normal can be found by evaluating $\textbf{n} = \nabla_{\textbf{x}}S$.

The obtained coordinate of surface point $\textbf{x}$ and surface normal $\textbf{n}$ are then can be used by appearance component of PhySG to render the pixel's color. Therefore, **to optimize the geometry, gradient must flow through both $\textbf{x}$ and $\textbf{n}$ to the parameters of SDF $\Theta$**. And both of them can be done with ease (either by auto-differentiation library, or implicit differentiation).

However, the sphere tracing algorithm used to find such points and normals need not be differentiable, thus memory efficient.

## Appearance modeling

To model a single-material specular object in the scene with the idea of the rendering equation, two optimizable components are needed in PhySG pipeline:

1. **An environment map** (illumination)
2. **BRDF** consisting of spatially varying diffuse albedo and a shared monochrome isotropic specular component

Note that this method ***DO NOT*** model self-occlusion or indirect illumination, which can be achieved by clever, but costly techniques in classic rasterization pipeline or - yet the most accurate -  ray tracing.

One of the factors that makes physically-based rendering expensive is the fact that **the hemispherical integral in the rendering equation does not have a closed-form expression**. Thus, numerical evaluation is usually done with computationally expensive Monte-Carlo methods.

### Spherical Gaussian (SG)

In PhySG, for modeling glossy material and distant direct illumination, spherical Gaussians (SGs) can be adopted to efficiently approximate the rendering equation in closed form. 

An **$n$-dimensional spherical Gaussian (SG) is a spherical function** that takes the form:

$$ \begin{gather} G(\boldsymbol{\nu}; \boldsymbol{\xi}, \lambda, \boldsymbol{\mu}) = \boldsymbol{\mu} e^{\lambda ( \boldsymbol{\nu} \cdot \boldsymbol{\xi} -1)} \end{gather} $$

where $\boldsymbol{\nu} \in \mathbb{S}^{2}$ is the function input, $\boldsymbol{\xi} \in \mathbb{S}^{2}$ is the lobe axis, $ \lambda \in \mathbb{R}\_{+} $ is the lobe sharpness, and $\boldsymbol{\mu} \in \mathbb{R}_{+}^{n}$ is the lobe amplitude.

### Environment map representation

Then **the environment map** $L_{i} (\boldsymbol{\omega}_{i}; \textbf{x}) = L(\boldsymbol{\omega}_i)$ (incident ray direction $\boldsymbol{\omega}_i$ is dropped due to the distant illumination assumption) is represented with a mixture of $M = 128$ SGs:

$$ \begin{gather} L_{i} (\boldsymbol{w}\_i) = \sum_{k=1}^{M} G (\boldsymbol{\omega}_i; \boldsymbol{\xi}_k, \lambda_k, \boldsymbol{\mu}_k) \end{gather} $$

### BRDFs

At the same time, **the spatially-varying diffuse albedo** is represented as a MLP mapping a surface point $\textbf{x}$ to a color vector $\textbf{a}$, i.e., $\textbf{a} (\textbf{x}; \boldsymbol{\Phi})$. Just like geometric component, positional encoding is also applied to fit high-frequency texture details. This MLP consists of 4 nonlinear layers of width 512, and encode location $\textbf{x}$ with 10 frequencies.

For the shared specular component (I guess that the entire surface of the object has the single specular property), simplified Disney BRDF model is used:

$$ \begin{gather} f_{s}(\boldsymbol{\omega}_o, \boldsymbol{\omega}_i) = \mathcal{M} (\boldsymbol{\omega}_o, \boldsymbol{\omega}_i) \mathcal{D} (\textbf{h}) \end{gather} $$

where $ \textbf{h} = ( \boldsymbol{\omega}\_o + \boldsymbol{\omega}\_i) / \vert\vert \boldsymbol{\omega}\_o + \boldsymbol{\omega}\_i \vert\vert_{2} $, $\mathcal{M}$ accounts for the Fresnel and shadowing effects, and $\mathcal{D}$ is the normalized distribution function.

The specular BRDF in simplified Disney BRDF is constructed as the following:

$$ \begin{gather} \mathcal{M} (\boldsymbol{\omega}_{o}, \boldsymbol{\omega}_{i}) = \frac{\mathcal{F}(\boldsymbol{\omega}_{o}, \boldsymbol{\omega}_{i}) \mathcal{G}(\boldsymbol{\omega}_{o}, \boldsymbol{\omega}_{i})}{4 (\textbf{n} \cdot \boldsymbol{\omega}_{o})(\textbf{n} \cdot \boldsymbol{\omega}_{i})}, \,\, \text{where} \\\\
\mathcal{F}(\boldsymbol{\omega}_{o}, \boldsymbol{\omega}_{i}) = \textbf{s} + (1 - \textbf{s}) \cdot 2 ^{- (5.55473 \boldsymbol{\omega}_{o} \cdot \textbf{h} + 6.8316)(\boldsymbol{\omega}_{o} \cdot \textbf{h})}, \\\\
\mathcal{G} (\boldsymbol{\omega}_{o}, \boldsymbol{\omega}_{i}) = \frac{\boldsymbol{\omega}_{o} \cdot \textbf{n}}{\boldsymbol{\omega}_{o} \cdot \textbf{n} (1-k) + k} \cdot \frac{\boldsymbol{\omega}_{i} \cdot \textbf{n}}{\boldsymbol{\omega}_{i} \cdot \textbf{n} (1-k) + k} \end{gather} $$

where $\textbf{s} \in [0, 1]^{3}$ is the specular albedo, $R \in \mathcal{R}_{+}$ is roughness, and $k = (R+1)^{2} / 8$. And the functions $\mathcal{F}$, $\mathcal{G}$ are Fresnel and shadowing terms, respectively.

On the other hand, $\mathcal{D}$ is represented with a single SG:

$$\mathcal{D} (\textbf{h}) = G(\textbf{h}; \boldsymbol{\xi}, \lambda, \boldsymbol{\mu})$$

since the paper assumed that the specular BRDF is isotropic, the lobe axis $\boldsymbol{\xi}$ must be aligned with surface normal, i.e. $\boldsymbol{\xi} = \textbf{n}$. Also, the monochrome assumption makes the three numbers in $\boldsymbol{\mu}$ identical.

When computing the rendering equation at a point $\textbf{x}$ with surface normal $\textbf{n}$ viewed along direction $\boldsymbol{\omega_{o}}$, $\mathcal{D}$ must be spherically warped, while $\mathcal{M}$ must be approximated by a constant at this specific location $\textbf{x}$:

$$ \begin{gather} \mathcal{D}_{\textbf{x}} (\textbf{h}) = G (\textbf{h}; \textbf{n}, \frac{\lambda}{4 \textbf{h} \cdot \boldsymbol{\omega}_{o}}, \boldsymbol{\mu}), \\
\mathcal{M}_{\textbf{x}} (\boldsymbol{\omega}_{o}, \boldsymbol{\omega}_{i}) \approx \mathcal{M} (\boldsymbol{\omega}_{o}, 2 (\boldsymbol{\omega}_{o} \cdot \textbf{n})\textbf{n} - \boldsymbol{\omega}_{o}) \end{gather} $$

Note that $ \boldsymbol{\omega}\_{i} $ is approximated to $ 2 (\boldsymbol{\omega}\_{o} \cdot \textbf{n})\textbf{n} - \boldsymbol{\omega}_{o} $, under the perfect mirror reflection assumption, removing the dependence of $\textbf{x}$.

Therefore, for the point $\textbf{x}$, by combining what we've discussed so far:

$$ \begin{gather} f_{s} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}\_{i}; \textbf{x}) = G (\textbf{h}; \textbf{n}, \frac{\lambda}{4 \textbf{h} \cdot \boldsymbol{\omega}\_{o}}, \mathcal{M}_{\textbf{x}} \boldsymbol{\mu}) \end{gather} $$

Now, both $ L_{i} (\boldsymbol{\omega}\_{i}) $ and $ f_{r} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}\_{i}; \textbf{x}) = \frac{\textbf{a}}{\pi} + f_{s} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}_{i}; \textbf{x}) $ in the rendering equation are approximated with SGs. Then the remaining term $ (\boldsymbol{\omega}_i \cdot \textbf{n}) $ can also be approximated with a SG of form:

$$\boldsymbol{\omega}_{i} \cdot \textbf{n} \approx G (\boldsymbol{\omega}_i ; 0.0315, \textbf{n}, 32.7080) - 31.7003$$

Until now, we have succesfully replaced all the terms inside the integral of the rendering equation, so what's remaining is to perform integration of the multiplication of these SGs in closed-form which gives us the observed color $L_{o} (\boldsymbol{\omega}_{o}; \textbf{x})$.

Finally, one would identify the optimizable parameters in each of SGs,

- **Environment map**: $ \\{ \boldsymbol{\xi}\_{k}, \lambda_{k}, \boldsymbol{\mu}\_{k} \\}_{k=1}^{M} $
- **Specular BRDF**: $ \\{ \lambda, \boldsymbol{\mu} \\} $
- **Spatially-varying diffuse albedo**: $ \boldsymbol{\Phi} $

respectively.

## Forward rendering

We now have representations for geometric and appearance components. Then the process of **forward rendering of a ray's color** is the following:

1. Use sphere tracing to find the intersection point $\textbf{x}$ between the ray $\textbf{r} = \textbf{o} + t \textbf{d}$ and the surface $S(\textbf{x}; \Theta) = 0$.
2. Compute the surface normal $\textbf{n} = \nabla_{\textbf{x}} S$ at $\textbf{x}$ via automatic differentiation.
3. Compute the diffuse albedo $\textbf{a} (\textbf{x}; \boldsymbol{\Phi})$ at $\textbf{x}$.
4. Use the surface normal $\textbf{n}$, environment map $ L_{i} (\boldsymbol{w}\_i) $, diffuse albedo $\textbf{a}$, specular BRDF $ f_{s} (\boldsymbol{\omega}\_{o}, \boldsymbol{\omega}_{i}; \textbf{x}) $, and viewing direction $\textbf{d}$ to compute the color for ray $\textbf{r}$ by evaluating the rendering equation in closed form with SG approximation.

Surprisingly, this entire procedure is fully differentiable with respect to all parameters involving in the rendering since:

- The rendered color $ L_{o} (\boldsymbol{\omega}\_{o}; \textbf{x}) $ is differentiable with respect to the variables $\textbf{n}$, $ \\{ \boldsymbol{\xi}\_{k}, \lambda_{k}, \boldsymbol{\mu}\_{k} \\}_{k=1}^{M} $, $\textbf{a}$, $ \\{ \lambda, \boldsymbol{\mu} \\}$ in the last step described above. → The SG renderer is simply the closed-form integration of spherical Gaussians.
- The spatially-varying diffuse albedo $\textbf{a} = \textbf{a}(\textbf{x}; \boldsymbol{\Phi})$ is nothing but an MLP, regarded as a polynomial function mathematically, which is differentiable. Thus, the rendered color is also differentiable with respect to $\boldsymbol{\Phi}$.
- It's shown that there exist gradients of both $\textbf{x}$ and $\textbf{n}$ with respect to the SDF parameters $\Theta$. Therefore, by the chain rule, the rendered color is also differentiable with respect to $\Theta$.

## Loss functions

To optimize the parameters of the model, a set of images and their corresponding viewpoints are used. PhySG render images from these viewpoints, and **each image is compared with ground truth image via $\ell_1$ image reconstruction loss**.

Also, the authors enforced non-negative minimum SDF values along non-object pixel rays indicated by object segmentation masks. And regularized the SDF's gradient to have unit norm.

More precisely, at each training iteration, what happens is the following:

1. Randomly sample a batch of pixels consisting of: object pixels $ \textbf{r}\_{i}^{obj} $ with ground truth color $ \\{ \textbf{c}\_{i}^{\text{gt}} \\}\_{i=1}^{N_{\text{obj}}} $, and non-object pixels $ \\{ \textbf{r}\_{i}^{\text{nobj}}\\}\_{i=1}^{N_{\text{nobj}}} $.
2. Render colors $ \textbf{c}\_{i}^{\text{obj}} $ for $ \textbf{r}\_{i}^{obj} $, while finding the minimal SDF value $S_{i}^{\text{nobj}}$ along camera rays $\textbf{r}_{i}^{\text{nobj}}$ by taking the minimal SDF value among 100 points uniformly lying on the ray segment inside object bounding box.
3. Randomly sample $ \\{ \textbf{x}\_{i} \\}_{i=1}^{N_x} $ inside the object bounding box.

Then the full loss is computed as:

$$ \begin{gather} \ell = \frac{1}{N_{\text{obj}}} \sum_{i=1}^{N_{\text{obj}}} \vert\vert \textbf{c}\_{i}^{\text{obj}} - \textbf{c}_{i}^{\text{gt}} \vert\vert_1 \\
+ \beta_{1} \frac{1}{N_{\text{nobj}}} \sum_{i=1}^{N_{\text{nobj}}} \frac{\ln (1 + e^{-\alpha S_{i}^{\text{nobj}}})}{\alpha} \\
+ \beta_{2} \frac{1}{N_x} \sum_{i=1}^{N_{x}} \vert\vert \vert\vert \nabla_{\textbf{x}\_{i}} S \vert\vert_{2} - 1 \vert\vert_{2}^{2} \end{gather} $$

where $\ln (1 + e^{-\alpha S_{i}^{\text{nobj}}}) / \alpha$, $\alpha > 0$ is a **smooth approximation of a horizontally flipped ReLU** $$\text{max} \{ -S_{i}^{\text{nobj}}, 0 \}$$, and $\beta_{1}$ and $\beta_{2}$ are weights balancing different loss terms.

The authors set $\beta_{1} = 100$, $\beta_{2} = 0.1$, $N_{\text{obj}} + N_{\text{nobj}} = 2048$, $N_x = 1024$ in their experiments. $\alpha$ grows from 50 to 1600 during training.

Furthermore, instead of sampling $N_{\text{obj}} + N_{\text{nobj}}$ independent pixels, the authors sampled $\frac{N_{\text{obj}} + N_{\text{nobj}}}{4}$ patches of size $2 \times 2$, and added the **additional loss term to penalize the variance of surface normals inside patches consisting only of object pixels** (i.e. calculate this only for such patches). This is natural since a small (infinitesimal) region of object surface should have continuous variation of normals. The weight for this smoothness loss is set to 10.

## Initialization

The SDF weights $\Theta$ are initialized using the method from the paper *Implicit geometric regularization for learning shapes, Gropp et al.* such that the initial shape is roughly a sphere. **→ Note that PhySG *refines* the geometry starting from a sphere, it may not be applicable to other geometries having completely different topologies**.

The diffuse albedo $\textbf{a} (\textbf{x}; \boldsymbol{\Phi})$ is initialized such that predicted albedo is around 0.5 at all locations inside the object bounding box.

For the specular BRDF, the initial lobe sharpness $\lambda$ is randomly drawn from $[95, 125]$, while the initial specular albedo $\boldsymbol{\mu}$ is randomly drawn from [0.18, 0.26] (note that all elements of $\boldsymbol{\mu}$ share the same value due to monochromatic assumption).

In the case of the environment map, the lobes are initialized to distribute uniformly on the unit sphere using a spherical Fibonacci lattice, with monochrome colors. And the intensity of lobes' (remember that the environment map is expressed as the sum of $M$ individual SGs) are scaled randomly so the initial rendered pixel intensity output is around 0.5.

Additionally, it's possible that different captures (even taken from a single scene!) might have significant gaps in exposure, all input images of an object is scaled with the same constant such that the median intensity of all scaled images is 0.5. → Empricially found that **the diffuse albedo MLP fails to learn albedo properly when trained with either too bright or too dark environment map**.

# Experiments

***For detailed experiment setups, please refer to the original paper. This post describes only the basic experimental settings and some quantitative results.***

PhySG pipeline is validated on both synthetic and real-world datasets.

Synthetic dataset is created by rendering 200 images per object using colored environmental lighting using the Mitsuba renderer, and 100 images among them were used for training while the others were used as test data.

For real-world scenes, the following datasets were used:

- **SLF dataset**
- **DeepVoxels**
- **Bag of Chips**
- **DTU dataset**

## Comparison with baselines

<img class="img-fluid" src="/assets/post-images/PhySG/PhySG_comparison_previous_methods.png">
<span class="caption text-muted">Figure 3. <b>Comparison with previous methods on both synthetic and real world data</b>.</span>

Along with PhySG, other neural rendering techniques such as NeRF, IDR, DVR are chosen as baselines, since they are the ones most related to this work. Although these methods can be trained end-to-end from multi-view 2D images, they are different from PhySG in a way that they represent scenes. We can say that all of them (including PhySG itself) model appearance as an MLP-represented surface (maybe volume) light field but these are particularly different in details:

- NeRF: Maps location $\textbf{x}$ and viewing direction $\sigma$ to a color
- IDR: Maps $\textbf{x}$, $\textbf{d}$ and surface normal $\textbf{n}$ to a color
- DVR: Takes ony $\textbf{x}$

As one can see from the figure above, **NeRF reconstructs the object surface poorly in view extrapolation because its volumetric representation does not concentrate colors near the surfaces**. While both IDR and DVR take surface-based approach, **DVR also fails to reproduce the surface since it lacks the view-dependent information**, which is a key feature involving in glossy, specular effects. While **IDR seems better than these two and works well, it also cannot synthesize specular highlights** since it doesn't have any physical model under the hood.

Compared to these methods, PhySG successfully synthesizes novel views with accurate specular effects. Furthermore, note that this method also enables us to edit the appearance whereas other three methods cannot.

<img class="img-fluid" src="/assets/post-images/PhySG/PhySG_editing_material.png">
<span class="caption text-muted">Figure 4. <b>Editing materials and lighting of the real-world captures</b>. For several input images, each figures in the same row from left to right: a real photo from the test set, image synthesized by PhySG, estimated diffuse (only) image, editing result by painting diffuse albedo, relighting results under two novel environmental illuminations, and estimated surface normal.</span>

Observe that scenes can be altered by modifying the scene representation obtained by PhySG through training. And they can be manipulated in physically-intuitive manner, yielding plausible and photorealistic images.

## Robustness to material roughness

<img class="img-fluid" src="/assets/post-images/PhySG/PhySG_editing_material.png">
<span class="caption text-muted">Figure 5. <b>Ground truth and reconstructed environment maps for the synthetic Kitty data</b>.</span>

**One possible drawback of this method is that it relies on specular highlights to estimate the lighting condition and material properties**. Thus, one might come up with a question such as *"What if the material of our interest is purely Lambertian?" (i.e. no specular reflection to guide PhySG)* To answer this question, the authors also empricially tested the capability of PhySG using the scenes consist of objects having rough surface (i.e. less specular, but more diffuse). And it turned out that **PhySG can reconstruct a reasonable-looking environment map even from very weak specular highlights**.

<img class="img-fluid" src="/assets/post-images/PhySG/PhySG_results_synthetic.png">
<span class="caption text-muted">Figure 6. <b>Results of PhySG pipeline on synthetic data</b>.</span>

# Conclusion

## Pros

- Proposed PhySG, an end-to-end inverse rendering pipeline that uses physics-based differentiable rendering.
- SDF for geometry and spherical Gaussian (SG) for appearance.
- PhySG can jointly recover environment maps, material BRDFs, and geometry from multi-view images captured under static illumination.
- This disentanglement, physics-based approach enables users to edit materials and relight the scenes.

## Cons

- **Indirect illumination is not modelled** by SG approximation of rendering equation → Cannot accurately model scenes with multiple objects, where indirect lighting matters
- Assumption on constant and monochrome specular BRDFs → due to the scale ambiguity between illumination and reflectance
- No support for anisotropic materials → Possibly handled by another SG which approximates terms in the rendering equation, especially the ones involving in anisotropic light bounces.