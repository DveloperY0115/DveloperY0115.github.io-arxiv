---
layout: post
title: "Summary of 'NeuTex: Neural Texture Mapping for Volumetric Neural Rendering'"
use_math: true
background: '/assets/post-images/NeuTex/NeuTex_overview.png'
---

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_overview.png">
<span class="caption text-muted">Figure 1. <b>NeuTex overview</b>. NeuTex separates the volumetric 3D geometry and the surface appearance represented as 2D UV map.</span>

# Motivation

- Volumetric scene representations combined with differentiable volume rendering can enable photo-realistic rendering on scene having high-complexity. However, **these methods entangle geometry and appearance, thus scene is not editable.**

# Key Contributions

- An approach that explicitly **disentangles geometry** (represented as a continuous 3D volume) **from appearance** (represented as a continuous 2D texture map).
- Introducing a 3D-to-2D texture mapping (or surface parametrization) network into the pipeline.
- 2D-to-3D inverse mapping and a novel cycle consistency loss to ensure consistent matching (similar to one-to-one correspondance) between a surface point in 3D and a point on UV map, which is a subset of 2D space.
- As a result of separating geometry and appearance, one can edit appearance by editing 2D texture maps extracted during the training.

# Key Concepts

## TL;DR

**NeuTex** is a neural scene representation that represents **geometry as a 3D volume** but **appearance as 2D neural texture in an automatically discovered texture UV space**.

Basic idea still remains the same. In order to render the scene, sampling point in 3D space by ray marching and accumulating per-point radiance values must be done. 

However, while NeRF uses a single MLP to regress both density and radiance in 3D volume, NeuTex has 4 networks which disentangles radiance from geometry:

1. $$ F_{\text{uv}} $$: For mapping 3D coordinate to a 2D coordinate in UV space
2. $$ F^{-1}_{\text{uv}} $$: As the inverse of $$ F_{uv} $$ to exploit the cycle loss to enforce consistency
3. $$ F_{\text{tex}} $$: A network which maps UV coordinate to actually texture RGB color in color space
4. $$ F_{\sigma} $$: A network inferring density (i.e. geometry) given a point in 3D space

While NeuTex is more constrained than a fully-volumetric method and outputs slightly worse results, this approach is still able to perform photorealistic novel view synthesis. Most importantly, **this is the first work introducing functionality for editing appearance of the object.**

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_method_overview.png">
<span class="caption text-muted">Figure 2. <b>Method overview</b>. This work presents a disentangled neural representation consisting of multiple MLPs for neural volumetric rendering.
</span>

## Disentangled neural scene representation

### Volume Rendering

Volume rendering requires volume density $\sigma$ and radiance $\textbf{c}$ at all 3D locations in a scene. Then a pixel's radiance value (RGB) $\textbf{I}$ is computed by ray marching algorithm, which samples points in 3D space along a specific ray. Specifically, 

$$\textbf{I} = \sum_{i} T_i (1 - \text{exp}(- \sigma_i \delta_i)) \textbf{c}_i, \\

T_i = \text{exp}(- \sum_{j=1}^{i-1} \sigma_j \delta_j)$$

where $i = 1, \dots, N$ denotes the index of a shading point on the ray, $\delta_i$ represents the distance between two consecutive points, $T_i$ is known as the transmittance, and $\textbf{c}_i$ and $\sigma_i$ are the radiance and volume density at $i$-th shading point, respectively. Notice that this is a discretized sum derived from the original continuous integral.

### Radiance Field

A general volume scene representation can be seen as a 5D function (i.e. a radiance field):

$$F_{\sigma, \textbf{c}}: (\textbf{x}, \textbf{d}) \to (\sigma, \textbf{c})$$

which outputs volume density and radiance $(\sigma, \textbf{c})$ given a 3D location $\textbf{x} = (x, y, z)$ and viewing direction $\textbf{d} = (\theta, \phi)$. NeRF approximated this per-scene radiance field as a single MLP network which encapsulates the entire scene geometry and appearance as a whole. However, this approach bakes the scene into the network, not allowing any modification after training.

### Disentangling

However, NeuTex explicitly decomposes the radiance field $F_{\sigma, \textbf{c}}$ into two components, $F_{\sigma}$ and $F_{\textbf{c}}$, modeling scene geometry and appearance, respectively.

$$F_{\sigma} : \textbf{x} \to \sigma, \quad F_{\textbf{c}}: (\textbf{x}, \textbf{d}) \to \textbf{c}$$

### Texture mapping

And the network $F_{\textbf{c}}$ can further be decomposed into two sub-networks $F_{\text{uv}}$ and $F_{\textbf{tex}}$. This decomposition allow us to model scene appearance in a 2D texture space that explains the object's 2D surface appearance as conventional texture mapping with mesh representations. 

In this setting, a 3D point $\textbf{x} = (x, y, z)$ in a volume is first mapped onto a 2D UV coordinate $\textbf{u} = (u, v)$ in a texture. Then we define another mapping that maps this UV coordinate and viewing direction vector $\textbf{d}$ (to model view-dependent appearance changing) to a color $\textbf{c} = (r, g, b)$ in color space. These mappings are approximated with neural network such that:

$$F_{\text{uv}}: \textbf{x} \to \textbf{u}, \quad F_{\text{tex}}: (\textbf{u}, \textbf{d}) \to \textbf{c}$$

Then the appearance function $F_{\textbf{c}}$ introduced previously can be expressed as:

$$F_{\textbf{c}}(\textbf{x}, \textbf{d}) = F_{\text{tex}}(F_{\text{uv}}(\textbf{x}), \textbf{d})$$

### Neural representation

To sum up, NeuTex way of scene representation can be thought as a composition of three functions: a geometry function $F_{\sigma}$, a texture mapping function $F_{\text{uv}}$, and a texture function $F_{\text{tex}}$, given by:

$$(\sigma, \textbf{c}) = F_{\sigma, \textbf{c}}(\textbf{x}, \textbf{d}) = (F_{\sigma}(\textbf{x}), F_{\text{tex}}(F_{\text{uv}}(\textbf{x}), \textbf{d}))$$

In total, three separate MLP networks for $F_{\sigma}$, $F_{\text{uv}}$ and $F_{\text{tex}}$ are used.

## Texture space and inverse texture mapping

Texture space used in this study is parametrized by a 2D UV coordinate $\textbf{u} = (u, v)$. While **any continuous 2D topology can be used for the UV space, 2D unit sphere is mostly used**. Then, $\textbf{u}$ is interpreted as a point on the unit sphere.

However, as mentioned earlier, **directly training three networks $F_{\sigma}$, $F_{\text{uv}}$, and $F_{\text{tex}}$ with pure rendering supervision leads to a highly distorted texture space and degenerate cases** (e.g. multiple points map to the same UV coordinate). Meanwhile, the desired way is to uniformly map the 2D surface onto the texture space preventing different points from being mapped to the single point in UV space.

A possible walkaround for this problem is to introduce the inverse network, $F_{\text{uv}}^{-1}$, opposed to $F_{\text{uv}}$, which maps a 2D UV coordinate $\textbf{u}$ on the texture to a 3D point $\textbf{x}$ in the volume:

$$F_{\text{uv}}^{-1}: \textbf{u} \to \textbf{x}$$

This function projects the 2D texture space onto a 2D manifold. Including this inverse transform allow us to reason about the 2D surface of the scene, and regularizes the texture mapping process, preventing the network from producing degenerate mappings due to too much degree of freedom during training.

Together, $F_{\text{uv}}$ and $F_{\text{uv}}^{-1}$  forms a cycle mapping between the 2D object surface and the texture space, leading to high-quality texture mapping.

## Training neural texture mapping

Then our next question would be: *"How can we enforce $F_{\text{uv}}$ and $F_{\text{uv}}^{-1}$ to be a mapping similar to one-to-one correspondance?"*

With this question in mind, we'll cover the losses used in the paper guiding the network to learn proper geometric & appearance representation of the scene.

### Rendering loss

As in NeRF, one straightforward to measure the quality of synthesized image is the direct comparison with the ground truth. Thus, the rendering loss per pixel is the $L_2$ distance between estimated pixel radiance and the one from ground truth:

$$L_{\text{render}} = \vert\vert \textbf{I}_{\text{gt}} - \textbf{I} \vert\vert^{2}_{2}$$

This is the main source of supervision.

### Cycle loss

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_checkerboard.png">
<span class="caption text-muted">Figure 3. <b>A checkerboard texture applied to scenes</b></span>

Suppose that we have a shading point $$ \textbf{x}_i $$ on a ray obtained by ray marching. Then previously suggested texture mapping network $$ F_{\text{uv}} $$ finds its UV $$ \textbf{u}_i $$ in texture space for radiance regression. Then, the inverse mapping network $$ F_{\text{uv}}^{-1} $$ is used to map this point back to the 3D space:

$$\textbf{x}_i^{\prime} = F_{\text{uv}}^{-1}(F_{\text{uv}}(\textbf{x}_i))$$

By minimizing the distance between $\textbf{x}_i$ and $\textbf{x}_i^{\prime}$, the network can learn the proper mapping between 3D space where geometry lies in and 2D UV space.

However, note that it's redundant and unreasonable to enforce a cycle mapping at *any* 3D point. Since the texture is mapped *onto* the surface of geometry, we only expect a correspondance between the texture space and points on the 2D *surface* of the scene. That being said, it's **meaningless enforcing the cycle mapping in the empty space far away from the surface**. Thus, from the intuition that the pixel is mostly affected by a shading point on, or nearby the surface, we leverage the radiance contribution weights per shading point to weigh our cycle loss. Specifically the weight we consider here is:

 

$$w_i = T_{i} (1 - \text{exp}(\sigma_i \delta_i))$$

which determines the contribution to the final pixel color for each shading point $i$. This weight implies how close a point is to the surface, thus suitable for our purpose. Then the cycle loss for a single ray is given by:

$$L_{\text{cycle}} = \sum_{i} w_i \vert\vert F_{\text{uv}}^{-1} (F_{\text{uv}} (\textbf{x}_i)) - \textbf{x}_i\vert\vert_{2}^{2}$$

### Mask loss

This additional loss is built upon the purpose of supervising a foreground-background mask. 

The transmittance used consistently in NeRF and its variants has the physical meaning that whether the $i$-th point along a ray is occluded by the other densities before that or not. 

Thus, it's natural to interpret the transmittance $T_N$ at the last shading point on a pixel ray as an indicator, saying that whether the pixel color is from the part of the background or not (i.e. if the transmittance at $N$-th sample is close to 1, it's almost not occluded by any other objects in the scene).

Given the ground truth mask $M_{\text{gt}}$ per pixel, then the mask loss can be computed as:

$$L_{\text{mask}} = \vert\vert M_{\text{gt}} - (1 - T_N) \vert\vert_{2}^{2}$$

Experimentally discovered fact is that, this loss is necessary when viewpoints do not cover the object entirely, so the large portion of the ground truth image is originated from the background of the scene. In such situation, the network can produce hallucinates, which is not the desired behavior. When the view coverage is dense enough, this loss is often optional.

### Full loss

Finally, the loss $L$ used during training is of form:

$$L = L_{\text{render}} + a_1 L_{\text{cycle}} + a_2 L_{\text{mask}}$$

$a_1 = 1$ is used for all scenes in the experiments, whereas $a_2 =1$ is used for most of the scenes, except for those having good view coverage. For such exceptional cases, the mask loss is dropped by setting $a_2 = 0$.

# Implementation & Experimental Results

## Network details

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_network_structure.png">
<span class="caption text-muted">Figure 4. <b>Network structure for the 4 networks</b>.</span>

- All four sub-networks, $F_{\sigma}$, $F_{\text{tex}}$, $F_{\text{uv}}$, and $F_{\text{uv}}^{-1}$, are designed as **MLP** networks.
- Both viewing direction $\textbf{d}$ and UV coordinate $\textbf{u}$ are represented as **unit vectors**.
- **Positional encoding** is also used just like NeRF did, to infer high-frequency geometry and apearance details. Precisely, the positional encoding is applied for geometry network $F_{\sigma}$, and texture network $F_{\text{tex}}$ on all their input components including $\textbf{x}$, $\textbf{u}$ and $\textbf{d}$. For those networks $F_{\text{uv}}$ and $F_{\text{uv}}^{-1}$, positional encoding is not used since it's expected to be smooth and uniform.

## Training details

Before training, **the scene space is normalized to the unit box** (remember that NeRF requires near and far boundaries for ray marching). Then the shading points on each pixel ray are sampled inside the box.

Unlike NeRF which used hierarchical sampling for enhancing the quality of the rendered image, **NeuTex uses only stratified but coarse sampling** (uniform sampling with local jittering) to sample 256 point on each ray for ray marching.

For each iteration, **the number of pixels in a batch is sampled randomly** in between 600 and 800, and this number of pixels are sampled from an input image. Idealy, 2/3 pixels are from foreground with the rest of them are from background.

The inverse mapping network $F_{\text{uv}}^{-1}$ **is initialized with a point cloud from COLMAP using a Chamfer loss**. However, since the MVS point cloud is often very noisy, Chamfer loss is only used for initialization. Although, NeuTex works fine without it in most cases, it seems to help a bit. What's more interesting to see is that **even though $F_{\text{uv}}^{-1}$ is initialized with very noisy geometry at the beginning, it succesfully learns smooth, continuous mapping** from 3D space to 2D UV space, after training with rendering and cycle loss together.

To be more specific, the training is done following the procedure below:

1. Train the entire network using the Chamfer loss and the rendering loss for 50,000 iterations.
2. Remove the Chamfer loss and train with the full loss suggested in the paper until convergence (takes around 500,000 iterations).
3. Fine-tune the texture network $F_{\text{tex}}$ until convergence, while fixing the parameters of the other networks.

**The entire process described above takes about 2-3 days on a single RTX 2080Ti GPU.**

## Results - View Synthesis

**For more details, please refer to the paper.**

The datasets used for the experiments are the following:

- 5 scenes from DTU dataset → 49 or 64 input images from multiple viewpoints per scene
- 2 scenes from Neural Reflectance Fields → about 300 images per scene
- 3 scenes crafted by the authors of NeuTex → about 100 images per scene

Since this work is about capturing surface of the objects, **the input images should have a clean, easily segmentable background**. To obtain it, U2Net is used to automatically compute masks for the scenes captured by the authors. Other datasets also have exact masks or image features that does the similar thing (e.g. images in Neural Reflectance Fields dataset are already have very dark background, eliminating the need of masking)

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_DTU.png">
<span class="caption text-muted">Figure 5. <b>Comparisons on DTU scenes</b>. Note that NeuTex is on par with NeRF, while supporting texture editing.</span>

## Results - Texture mapping and appearance editing

**NeuTex is the first neural rendering method that extracts texture mapping from the scene, and most importantly, enables surface appearance editing in a 2D texture space** (discovered by NeuTex). One can see in (Fig. 6.d) that it also successfully unwraps the object surface into a reasonable texture.

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_texture_editing.png">
<span class="caption text-muted">Figure 6. <b>Texture editing on DTU (rows 1-2) and the scenes from author (rows 3-5)</b>.</span>

Furethermore, as one can see from (Fig 6. e ~ g), the texture can be modified either globally or locally. That is, one can either modify the entire material, or just add some patterns onto the existing texture. Those appearance editing can directly be done in the discovered texture space, and the scene still looks natural and view point consistent after such modification. **→ NeuTex successfully disentangles the geometry and appearance of real objects and model the surface appearance in a meaningful texture space.**

### Results - Extension to reflectance fields

<img class="img-fluid" src="/assets/post-images/NeuTex/NeuTex_reflectance_fields.png">
<span class="caption text-muted">Figure 7. <b>NeuTex in reflectance fields setting</b>. The captured diffuse albedo (d) is editted to be (g). The images produced using this modified albedo are shown in (e, f).</span>

NeuTex can regress normal $\textbf{n}$ and reflectance parameters $\textbf{r}$ at each shading point, instead of directly outputting radiance $\textbf{c}$. Then, reflectance-aware volume rendering method can be applied on such reflectance field, to compute radiance from these shading properties defined at each point in 3D volume. With this high-level idea in mind, we can modify some parts of NeuTex:

- Modify geometry network $F_{\sigma}$ to jointly regress volume density and normal (since normal is also geometric property)
- Modify texture regression network $F_{\text{tex}}$ to regress the reflectance parameters $\textbf{r}$ in the texture space.

The central UV mapping and its inverse network retain their original structure. This modified version of NeuTex can still generate plausible images via reflectance-aware volume rendering process. See (Fig. 7) for details.
