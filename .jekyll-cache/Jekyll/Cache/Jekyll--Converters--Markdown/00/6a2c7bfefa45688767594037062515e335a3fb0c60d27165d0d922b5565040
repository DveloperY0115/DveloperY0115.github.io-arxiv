I"Ai<h1 id="motivation">Motivation</h1>

<ul>
  <li>Humans can easily infer the underlying 3D geometry and texture of an object only from a single 2D image. <strong>Because we’ve seen many objects from many views</strong>. It’s the experience that enables us to infer a geometry and appearance of a novel object by exploiting the accumulated visual memories from similar category of objects.</li>
  <li>While current computer algorithms can do such task, they often suffer from view generalization problems making awkward images conditioned on novel viewpoints. Either the inferred mesh is distorted or the infferred textures are muddled, blurry, and missing details.</li>
</ul>

<p><img class="img-fluid" src="/assets/post-images/ViewGeneralizationSingleImage/fig1.png" />
<span class="caption text-muted">Figure 1. <b>Inferring high quality textured 3D models from a single 2D image input</b>.</span></p>

<h1 id="key-contributions">Key Contributions</h1>

<ul>
  <li>A controllable convolutional deformation approach for better recovery of 3D geometry of the objects. <strong>→ Specifically, the deformation is not directly done in 3D space, but the geometry is first mapped to 2D UV space, and them deformed there.</strong></li>
  <li>Two novel cycle consistency losses that improves overall inferred textured 3D models.</li>
  <li>High-fidelity textured 3D model synthesis from a single image both qualitatively and quantitatively.</li>
</ul>

<hr />

<h1 id="tldr">TL;DR</h1>

<p>The network infers both <strong>underlying geometry (mesh) and texture from a single 2D image</strong>. To generate parts of an object (both shape and texture) that were not visible from the input, the network exploits the previously seen images in similar categories but containing objects with different appearance, camera poses, etc. In order to successfully learn such behavior, it’s trained under two consistency losses proposed by the paper.</p>

<h1 id="method">Method</h1>

<p><img class="img-fluid" src="/assets/post-images/ViewGeneralizationSingleImage/fig1.png" />
<span class="caption text-muted">Figure 1. <b>Inferring high quality textured 3D models from a single 2D image input</b>.</span></p>

<p>Figure 2. <strong>Architecture overview</strong>. The framework learns to infer the 3D geometry (represented as a mesh) and the texture of an object given a single image that captures it. The final geometry and obtained by a weighted combination of object templates and refined through deformation.</p>

<h2 id="controllable-convolutional-deformation">Controllable Convolutional Deformation</h2>

<p>An encoder-decoder architecture encodes images into 3D geometry and decodes textures, and these are then fed into a differentiable renderer giving reconstructed input images with image-view camera parameters. For differentiable renderer in this pipeline, DIB-R is used.</p>

<p>To estimate 3D geometry with high accuracy, it’s necessary to <strong>control the model complexity and mesh deformation</strong>. This is very important since it’s often turns out to be difficult to find balance between flexibility for various images and rigidity for realistic rendering of novel views.</p>

<p>For example, a model that is too flexible might work for many kinds of images but each with unsatisfactory quality. On the other hand, a model which is too rigid may reconstruct input images with desirable photorealism, while completely failing to generate results conditioned on unknown viewpoints.</p>

<p>Previous methods used a fully connected linear layer to predict deformation of a template mesh. But this approach had several drawbacks.</p>

<ol>
  <li><strong>Each vertex is independently deformed</strong>, thus the overall geometric structure is not considered.</li>
  <li><strong>Fully connected linear layer does not provide controllability</strong> over deformation. While the model should be adjusted so that the deformation is done with flexibility (or rigidity) on certain types of geometry, it’s not achievable with fully connected layer. For instance, for non-rigid objects like birds, the model needs to be flexible enough.</li>
  <li>These <strong>deformations are bound to a specific set of vertices of a template mesh</strong> and difficult to re-sample for any new vertices.</li>
</ol>

<p>Thus, instead of approaches suggested in previous works, this paper utilizes a spherical mapping to map a mesh to a sphere. The resulting 2D UV map, thought as an unwrapped sphere having a fixed topology, can be used for deformation later on. <strong><em>→ Imagine applying this strategy for deforming shapes having different topology. What would happen?</em></strong></p>

<p>With this 2D UV map, <strong>a single spatial deformation UV map, which is a function whose domain is the sphere where the original surface is mapped, is predicted by a convolutional architecture</strong> (this is the reason why it’s called convolutional deformation). After prediction, the deformation per vertex of template mesh can be determined by sampling from the predicted deformation UV map using the position of vertex to be deformed.</p>

<p>This method works better than previous deformation methods, especially the most intuitive one - directly deforming the shape in 3D -  and additionally provides capability to adjust the amount of deformation to be applied by adjusting the resolution of the convolutional layer’s output.</p>

<p>For large deformation models (non-rigid shapes such as birds), the spatial resolution of deformation map is set to be high ($32 \times 32$), so that the deformation can alter the shape with high flexibility, giving natural shapes.</p>

<p>On the other hand, for small deformation models (rigid shapes such as cars), the convolutional network predicts low resolution deformation map ($2 \times 2$) or ($4 \times 4$) to restrict the number of vertices (mapped onto the UV map) to be deformed, so that the template mesh does not undergo too much modification (i.e. only small number of vertices in the original model are deformed).</p>

<p>This controllability, reffered as degree of deformation (DOD), is one of the key aspect of this work, and used throughout this work. Especially, in the literature, $\text{DOD} = 4$ means that the 2D deformation has $2 \times 2$ spatial resolution.</p>

<p>Since <strong>the deformation is learned for 2D UV map, not the template mesh</strong>, the number of vertices that associated deformations are sampled and then applied can be adjusted freely without extra computational cost.</p>

<h3 id="mesh-templates">Mesh templates</h3>

<p>This method refines geometry by starting from a template mesh to be deformed by the convolutional deformation on 2D spherical UV map discussed just before. Unlike previous methods starting with mean templates and learning to deform it, <strong>this method exploits multiple templates provided by PASCAL3D+ dataset, and a mean template for CUB dataset</strong>.</p>

<hr />

<p><strong>NOTE: This part is a bit ambiguous (to me).</strong></p>

<blockquote>
  <p><em>“The network learns w, the template weight, to choose one from $n$ templates it needs to start with for an image. However, we do not have any supervision for these templates, so we pre- dict normalized weights ($w$) of each template ($t$) and take their weighted sum as our predicted mesh template. We also use a learnable scale-factor ($s$) for each of these templates to adapt our templates to appropriate size.”</em></p>
</blockquote>

<p>The following questions emerge from the paragraph above.</p>

<ol>
  <li>What’s the exact purpose of (normalized) weights? Is this for <strong>picking the most probable template mesh as a starting point</strong>, or <strong>the template mesh is built by mixing the available templates using some inferred weight for each of them?</strong></li>
  <li>If it’s the second case, <strong>is it possible to define linear combination of two or more meshes?</strong> Is it possible to create a mesh as a weighted sum of base meshes?</li>
  <li>Is the preprocessing step related to this? What’s the condition required to mix two or more different meshes?</li>
</ol>

<p>For me, the sentence following the above paragraph,</p>

<blockquote>
  <p><em>“We then refine this predicted mesh by sampling deformation of all vertices ($\Delta V$) using the convolutional UV deformation map. Our final refined mesh vertices are $V = \sum_{i=1}^{n} s_i \times w_i \times V_i^t \,\, + \Delta V$.”</em></p>
</blockquote>

<p>implies that it’s possible to add two different meshes. Then, the vertices of template meshes must have correspondance between them, but there’s no mention about it.</p>

<hr />

<p>It’s shown in the experiments that using only a few additional templates improves textured 3D inference by large margin with only a single 2D image.</p>

<p>And the preprocessing for templates meshes were done as the following:</p>

<ol>
  <li>Remove all interior triangles and faces by simplifying mesh into voxels.</li>
  <li>Convert these voxels into a mesh by running a marching cubes algorithm.</li>
  <li>Simplify meshes by closing holes and decimating mesh.</li>
  <li>Use spherical parametrization and map spheres to the final meshes.</li>
</ol>

<p><strong>Note that any mesh that fails during each step was discarded and not used.</strong></p>

<p><strong><em>→ (2021. 07. 02. Update) Spheres are mapped to the simplified mesh created from the task 1 ~ 3. Thus, the above discussion (the one that I thought to be ambiguous) makes sense. Also, I think they assumed that the small perturbations applied on the vertices of meshes don’t change the relative position between vertices dramatically.</em></strong></p>

<h3 id="losses">Losses</h3>

<p>The bases losses are same as DIB-R, which is the work about the differentiable renderer used in this work.</p>

<p>For reconstruction, $\mathcal{L}<em>1$ image reconstruction loss between input image $I$ and the rendered image $I</em>{r}$ and perceptual loss from AlexNet $\Phi$ at different $j$-th feature layers are used. Concretely,</p>

\[\mathcal{L}_{\text{recon}} = \vert\vert I - I_r \vert\vert_{1}, \\
\mathcal{L}_{\text{percp}} = \vert\vert \Phi_{j}(I) - \Phi_{j}(I_{r}) \vert\vert_{2}\]

<p>For shapes, an IoU between the silhouette rendered $S_{r}$ and the silhouette $S$ of the input image is used:</p>

\[\mathcal{L}_{\text{sil}} = 1 - \frac{\vert\vert S \odot S_{r} \vert\vert_{1}}{\vert\vert S + S_{r} - S \odot S_{r} \vert\vert}\]

<p>Along with the silhouette loss, the predicted mesh is regularized with a smoothness loss and Laplacian loss ($\mathcal{L}_{\text{lap}}$). The purpose of taking these losses into account is to make normals of neighboring mesh triangles similar.</p>

<p>The camera pose is also predicted. And it’s used together with the ground truth camera pose to compute a simple $\mathcal{L}<em>2$ regression loss ($\mathcal{L}</em>{\text{cam}}$) (see the overall architecture).</p>

<p>Keypoints are predictd from the inferred mesh as well. As in the camera pose loss, it’s compared with the ground truth and gives us $\mathcal{L}<em>{2}$ regression loss ($\mathcal{L}</em>{\text{KP}}$).</p>

<p>Finally, the magnitude of deformation is regularized to be small, thus $\mathcal{L}_{\text{deform}}= \vert\vert \Delta V \vert\vert$ is minimized so that it becomes close to zero. Therefore, the baseline loss for this study is:</p>

\[\mathcal{L}_{\text{baseline}} = \lambda_{r} \mathcal{L}_{\text{recon}} + \lambda_{p} \mathcal{L}_{\text{percp}} + \lambda_{s} \mathcal{L}_{\text{sil}} \\ + \lambda_{c} \mathcal{L}_{\text{cam}} + \lambda_{\text{kp}} \mathcal{L}_{\text{KP}} + \lambda_{d} \mathcal{L}_{\text{deform}} + \lambda_{\text{lap}} \mathcal{L}_{\text{lap}}\]

<p>and the values for the coefficients are: $\lambda_{r} = 20$, $\lambda_{p} = 0.5$, $\lambda_{s} = 5.0$, $\lambda_{c} = 1$, $\lambda_{\text{kp}} = 50.0$ , $\lambda_{d} = 2.5$, $\lambda_{\text{lap}} = 5.0$.</p>

<p>Note that there’s no novelty in the loss introduced here. This will play the role as a baseline, and the effect of applying loss suggested by the authors will be presented soon.</p>

<h2 id="cycle-consistency-losses">Cycle-Consistency Losses</h2>

<p>One marvelous thing about human intelligence is that it makes decision based not only on the currently given condition (or circumstance), but also on the experience from the past. For instance, we can infer the overall shape of the mug, even if we only saw the part where the cup handle is. This is because, from the past experience, we already know what the overall shape of normal mug should be. And this is the key idea which should be understood well to achieve high performance in single shot reconstruction task like this.</p>

<p>To this end, this work suggests two cycle-consistency losses to guide the network to preserve both geometric and texture consistency when an object is observed in various viewpoints. By train the network under these losses, both texture and geometric information are <em>shared</em> across image collections.</p>

<ol>
  <li><strong>Rotation GAN cycle consistency loss</strong>: Keep rendered images from novel viewpoints as real as possible by implicitly constrain them on a multi-view cycle consistency based on GAN literature. (sharing geometric information across input images)</li>
  <li><strong>Texture-mesh alignment cycle consistency loss</strong>: Enforces consistent texture alignment to meshes irrespective of their views and shapes. (sharing texture mapping information across input images, keeping appearance consistency among different objects in the same class)</li>
</ol>

<h3 id="rotation-gan-cycle-consistency">Rotation GAN Cycle Consistency</h3>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_11.36.01.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_11.36.01.png" /></p>

<p>Figure 3. <strong>Rotation GAN Cycle Consistency</strong>.</p>

<p>It’s very hard to reconstruct a geometry and the suitable texture for an object given just a single image, since there’s no supervision from other viewpoints. Previous methods tried to overcome this problem by imposing a multi-view consistency loss, and rendered multiple views given a single image on synthetic ShapeNet dataset. <strong>→ Not applicable on real world images, since it’s difficult to acquire multi-view images.</strong></p>

<p>That being said, we need to fine another way to achieve multi-view consistency without exploiting a set of images. And the approach proposed by the authors is the following:</p>

<p>Let $M$ be a function which outputs 3D meshes given an input image, $T$ be a texture network, and $R$ be a differentiable renderer which outputs an image.</p>

<p>Given an image $X_1$ and its corresponding camera pose $C_1$, the framework first infer the underlying geometry and texture representation, and then renders a new, intermediate image $I_1$ seen from a novel camera view $C_2$.</p>

\[I_1 = R(M(X_1), T(X_1), C_2)\]

<p>and then <strong>using this intermediate image, the framework then infer the geometry and texture representation, just as it did for $X_1$, and render an image that would’ve been seen from</strong> $C_1$. More precisely,</p>

\[X_1^{\prime} = R(M(I_1), T(I_1), C_1)\]

<p>Ideally, two images $X_1$ and $X_1^{\prime}$ should be identical, since this indicates that the network is capturing the geometric and texture features well. To optimize the network to behave in that way, the reconstruction loss and perceptual loss are computed with $X_1$ and $X_1^{\prime}$.</p>

<p>In addition, the authors trained a U-Net discriminator to distinguish the real and fake images in both global and pixel-by-pixel level. <strong>This discriminator is then determines whether the intermediate image $I_1$ is fake or not</strong>, making another path for back propagation (through the intermediate image). The GAN loss then penalizes the network if the image from novel views are not realistic, guiding the network to generate realistic intermediate images.</p>

<p>As intermediate images become realistic over training due to the GAN loss, the cycle consistency loss then make use of these intermediate images, leading the network to correctly infer the occluded regions consistently in terms of geometry and texture.</p>

<p><strong>→ This constraint improves the overall quality of 3D reconstruction.</strong></p>

<h3 id="texture-mesh-alignment-cycle-consistency">Texture-Mesh Alignment Cycle Consistency</h3>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_11.47.36.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_11.47.36.png" /></p>

<p>Figure 4. <strong>Texture Mesh Alignment Cycle Consistency</strong>.</p>

<p>On the other hand, synthesizing accurate texture for an object in an image was the another objective of this work. “How can we do that?”</p>

<p>One important fact to notice is that the network can be easily overfitted due to the problem setting of single view reconstruction. The only information that the naive-neural network can utilize for synthesizing the texutre is the given single image. The artifact of overfitting is inconsistent, awkward, and distorted texture when seen from different viewpoints. Therefore, <strong>the key to solve this issue is to find a way to avoid overfitting the network to a specific image</strong>.</p>

<p>Inspired by the insight gained from human perception - depending on not only the information currently available, but refer to the past experience - one might come up with an idea to share the appearance information over the input images. And hopefully, the network can learn the underlying relation between shape and texture (e.g. inferring the location of headlights given an image showing the back of a car using <em>other images</em> depicting the front of various cars).</p>

<p>And this can be mimicked by constrain the network on the novel texture-mesh alignment cycle consistency loss. Suppose that we’re given two images $X_1$, $X_2$ each depicting different objects (e.g. cars in figure above), along with their corresponding camera poses $C_1$, $C_2$. Then the framework first makes inference on their 3D meshes and textures. Then, we <strong>swap textures</strong> to reconstruct two intermediate images such that:</p>

\[I_1 = R(M(X_1), T(X_2), C_1), \\
I_2 = R(M(X_2), T(X_1) , C_2)\]

<p>then the next step is to infer textures from these intermediate images and swap textures back onto their original geometries, reconstructing the original images:</p>

\[X_1^{\prime} = R(M(X_1), T(I_2), C_1), \\
X_2^{\prime} = R(M(X_2), T(I_1), C_2)\]

<p>Again, similar to rotation GAN consistency loss, the original image $X_i$ and $X_i^{\prime}$ should match ideally. By regularizing the network using the texture-mesh alignment loss, we can reduce the bias arose by taking only a single image into consideration during inference. Furthermore, another useful aspect of this loss is that the network can learn how the parts of a texture that were originally invisible or occluded should look like from the novel viewpoints. This definitely helps the network to recover accurate &amp; realistic textures.</p>

<h1 id="experiments">Experiments</h1>

<h2 id="datasets">Datasets</h2>

<ul>
  <li><strong>PASCAL3D+</strong>: Primarily used dataset → especially ‘car’ category for evaluations</li>
  <li><strong>CUBs</strong>: ‘Bird’ shape models were used for evaluation as well</li>
  <li>The same train-test split from DIB-R.</li>
  <li><strong>7 templates</strong> for deforming meshes, these templates were brought from PASCAL3D+ dataset and preprocessed following the steps introduced in the method section.</li>
  <li>But for birds, the framework starts from only a single template.</li>
</ul>

<h2 id="baselines--ablations">Baselines &amp; Ablations</h2>

<p>The model was compared mostly with <strong>the previous SOTA, DIB-R</strong>. The pretrained model of DIB-R was used for comparison. While DIB-R does not learn to infer camera poses, this work does. Also, DIB-R doesn’t utilize symmetry in both geometry and texture since this rather reduces the quality of inferenced 3D mesh and texture.</p>

<p>And there are three types of ablation studies:</p>

<ol>
  <li>Using <strong>single template vs multiple templates</strong></li>
  <li>Effectiveness of <strong>convolutional deformation</strong> over linear layer based deformation</li>
  <li>Role of <strong>novel cycle consistency losses</strong></li>
</ol>

<h2 id="model-details">Model Details</h2>

<p>Given an image, weights ($w$) for each template mesh and camera pose prediction is obtained by applying a single linear layer over ResNet18 features. Then the starting point mesh is created by simply compute a weighted average per template vertex, over the set of meshes.</p>

<p>For predicting texture maps and deformation (in the form of 2D UV map), U-Net architecture is used. Texture maps are predicted to have $256 \times 256$ resolution. For predicting deformations, UV maps having $DOD = 4$ or $2 \times 2$ spatial resolution are used for cars, while the ones with $DOD=256$ or $16 \times 16$ spatial resolution are used for birds.</p>

<p>The deformation is sampled using bilinear grid interpolation, by evaluating the interpolated deformation at the coordinate in 2D spherical UV map, that were mapped from a vertex of a mesh. This method reduces the computational cost by removing the necessity of computing deformation for each of the mesh vertices.</p>

<p>Two types of variants are tested for GAN architecture in the framework. While both of them treat the an image rendered from a novel view as fake, one used <em>input training images</em> as real while the other used <em>the rendered images from original viewpoint</em> as real. Notably, shapes were improved when the input training images are used as real, while appearances got better when the rendered images are used as real.</p>

<h2 id="evaluation">Evaluation</h2>

<p>Since there’s no ground truth 3D geometry and texture maps to evaluate, this study applied the same evaluation principles used in DIB-R. For geometry, <strong>mask and silhouette projection accuracy</strong> are used while <strong>FID scores</strong> are computed from the rendered images as a metric for realistic appearance reconstruction. Besides, <strong>user study</strong> was done to evaluate human preferances comparing this method with previous methods.</p>

<h2 id="results">Results</h2>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.06.59.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.06.59.png" /></p>

<p>Figure 5. <strong>Textured 3D inference on PASCAL3D+ cars</strong>.</p>

<p>The qualitative comparison between DIB-R, the previous SOTA, is shown above. While DIB-R generates good quality reconstructions from the original viewpoint, it suffers from distortion when conditioned on novel viewpoints compared to this method. The quantitative comparison in the table below represents this well. While DIB-R achieves the highest 2D mIoU conditioned on known viewpoints, still FID measure is quite high (higher, the worse) meaning that the reconstructed images are a bit unrealistic. Meanwhile, along with ablations, the newly suggested pipeline achieves better performance both in terms of mIoU and FID.</p>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.16.08.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.16.08.png" /></p>

<p>Figure 6. <strong>Quantitative results on PASCAL3D+ car dataset</strong>.</p>

<p>The similar discussion can be done on another category of shape - birds. Note that even for non-rigid geometry and appearance (organic structure such as a body of an organism) this method works quite well.</p>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.16.42.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.16.42.png" /></p>

<p>Figure 7. <strong>Textured 3D inference on the CUB dataset</strong>.</p>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.16.29.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.16.29.png" /></p>

<p>Figure 8. <strong>Quantitative results on CUB dataset</strong>.</p>

<p>Another aspect we need to look carefully is that the effect of resolution in convolutional deformation. In both qualitative and quantitative evaluation, one can clearly see that it’s necessary to differentiate the resolution of deformation according to the target shape.</p>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.22.03.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.22.03.png" /></p>

<p>Figure 9. <strong>DOD Ablation study (Quantitative)</strong>. Note that increasing DOD for rigid shapes (like cars) leads to worse performance while the reverse happens for flexible shapes (like birds).</p>

<p><img src="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.22.32.png" alt="View%20Generalization%20for%20Single%20Image%20Textured%203D%20M%2025860065232c44eb9f798cb1f0bdf0c9/_2021-07-02_16.22.32.png" /></p>

<p>Figure 10. <strong>DOD Ablation study (Qualitative)</strong>.</p>

<h1 id="conclusion">Conclusion</h1>

<ul>
  <li>Introduced a new 3D inference pipeline which reconstructs 3D mesh and its texture at the same time, from a single image.</li>
  <li>Convolutional deformation allow us to control the degree of deformation (DOD) by adjusting the resolution of the convolution feature map. And it’s computationally efficient since the deformation for each vertex is evaluated via sampling and interpolation from this deformation map.</li>
  <li>Two cycle consistency losses - rotation GAN, texture-mesh alignment - each related to view-dependent geometry and appearance consistency.</li>
  <li>Thanks to these novel components, this method achieved the SOTA performance, making improvements from the previous one.</li>
</ul>
:ET