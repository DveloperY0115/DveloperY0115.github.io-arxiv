<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    Summary of 'An Improved Illumination Model for Shaded Display' - DveloperY0115's Blog
    
  </title>

  <meta name="description" content="Motivations">

  <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

  <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dvelopery0115.github.io/2021/09/02/Whitted.html">
  <link rel="alternate" type="application/rss+xml" title="DveloperY0115's Blog" href="/feed.xml">

  <!-- Syntax highlighting -->
  <link rel="stylesheet" href="/assets/syntax.css" type="text/css">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


<body>

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">DveloperY0115's Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/posts">Posts</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead" style="background-image: url('/assets/post-images/Whitted/fig1.png')">
  
    <div class="overlay"></div>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <div class="post-heading">
            <h1>Summary of 'An Improved Illumination Model for Shaded Display'</h1>
            
            <h2 class="subheading">An Improved Illumination Model for Shaded Display (Commun. ACM, 23(6):343–349, 1980)</h2>
            
            <span class="meta">Posted by
              <a href="#">Seungwoo Yoo</a>
              on September 02, 2021 · <span class="reading-time" title="Estimated read time">
  
   16 mins  read </span>

            </span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">

        <h1 id="motivations">Motivations</h1>

<ul>
  <li>The goal of computer graphics has been achieving photorealism from the beginning. For instance, even the earliest algorithms included shaders that simulated effects such as specular reflection, shadows, and transparency.</li>
  <li>While several works demonstrate the importance of illumination models in practice, existing methods are usually limited in scope since they only focus on light sources and surface orientations (normally represented by normals), ignoring the effect of global illumination.</li>
</ul>

<h1 id="key-contributions">Key Contributions</h1>

<ul>
  <li>Proposes a novel rendering method based on physical simulation of light-surface interaction and recursive evaluation of intensities by tracing rays backward from the viewer.</li>
</ul>

<hr>

<h1 id="methods">Methods</h1>

<h2 id="conventional-models">Conventional Models</h2>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig1.png">
</center>
<p><span class="caption text-muted">Figure 1. <b>An example generated by using the method proposed in the paper</b>.</span></p>

<p>The simpliest visible surface algorithms use shaders based on Lambert’s cosine law. According to the law, the intensity of the reflected light is proportional to the dot product of the surface normal and the light source direction. However, note that we can only simluate a perfect diffuser (dull, matte surface) with this simple principle. For more sophiscated effect such as specular reflection which can easily be observed in materials like plastic, or metal, we need to add more terms in our model. One simple, yet powerful solution for simulating specular reflection is proposed by Bui-Tuong Phong in 1975. According to Phong’s model, the intensity is computed as:</p>

<p>$$
\begin{gather} 
I = I_{a} + k_{d} \sum_{j=1}^{j=ls} (\bar{N} \cdot \bar{L}<em>{j}) + k</em>{s} \sum_{j=1}^{j=ls} (\bar{N} \cdot \bar{L}_{j}^{\prime})^{n},
\end{gather}$$</p>

<p>where $I$ is the reflected intensity, $I_{a}$ is the reflection due to ambient light, $k_{d}$ is the diffuse reflection constant, $\bar{N}$ is the unit surface normal, $\bar{L}_{j}$ is the vector in the direction of the $j$th light source, $k_{s}$ is the specular reflection coefficient, $\bar{L}_{j}^{\prime}$ is the direction of halfway vector, and $n$ is an exponent which determines the glossiness of the surface. Note that only the last term is dependent to the viewing direction, and larger $n$ tends to make specular reflection more sharper.</p>

<p>However, Phong’s model assumes that each light source is located at a point infinitely far from the objects in the scene, thus do not consider:</p>

<ol>
  <li>objects within a scene acting as light sources</li>
  <li>light reflected from the surface of other objects in the scene</li>
</ol>

<p>While the model works sufficiently well with diffuse materials, it suffers from serious degrade of quality when it comes to specular reflections. For remedy, Blinn and Newell came up with an idea to tackle the problem by modeling an object’s environment and mapping it onto a sphere of infinite radius (the method so called <em>environment mapping</em>). However, this approach is not appropriate to apply in the general case.</p>

<p>Not only the specular reflection, but also the simulation of shadows is one of the features that we want an illumination model to support. The principle is still simple - a point on a surface lies in shadow if it is visible to the viewer but not visible to the light source. And various approaches has been proposed to draw more realistic shadows.</p>

<p>Last but not least, transmission of light <em>through</em> transparent objects has been simulated by painting surfaces in reverse depth order (i.e., similar to alpha compositing, partially overwrite background). Even though such technique showed impressive results, it could not simulate refraction.</p>

<h2 id="improved-model">Improved Model</h2>

<p>Then how can we build more realistic model for reflection? What is more physically accurate way to simulate light bouncing off from a point on a surface? Actually, classical ray optics already provides the answer in the case of perfect mirror reflection as illustrated in the figure below.</p>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig2.png">
</center>
<p><span class="caption text-muted">Figure 2. <b>Reflection and refraction of a ray at a point on a perfect mirror</b>.</span></p>

<p>The light intensity $I$ at a point on the surface observed by the viewer is determined by two primary components:</p>

<ul>
  <li>The specular reflection $S$</li>
  <li>The transmission $T$</li>
</ul>

<p>these intensities represent light propagated along the $\bar{V}$, $\bar{R}$, and $\bar{P}$ directions, respectively. Additionally, since the surfaces do not only exhibit specularity, we must add a term to model the diffuse component as well. Ideally, the diffuse reflection <em>should</em> contain components due to reflection of nearby objects as well as predefined light sources, then the computational cost will be increased dramatically making the rendering infeasible (<strong>Note: considered impossible in 1980, we are now able to simulate such light-surface interaction in real-time after 40 years</strong>). Therefore, the authors adopted the same diffuse model from previous works. Then the newly proposed model is:</p>

<p>$$
\begin{gather}
I = I_{a} + k_{d} \sum_{j=1}^{j=ls} (\bar{N} \cdot \bar{L}<em>{j}) + k</em>{s} S + k_{t} T,
\end{gather}
$$</p>

<p>where $S$ is the intensity of light incident from the $\bar{R}$ direction, $k_{t}$ is the transmission coefficient, and $T$ is the intensity of light from the $\bar{P}$ direction. Here, the coefficients $k_{s}$ and $k_{t}$ are held constant for the model, but the authors strongly recommend to regard them as functions each of which is an approximation of the Fresnel reflection law for better quality. In other words, these coefficient should also be dependent to the incidence angle. Even when they are fixed as constants, the actual values of them must be chosen with care in order to generate images that physically make sense.</p>

<p>The direction of reflected ray $\bar{R}$ is determined by the simple rule that the angle of reflection must equal the angle of incident. In similar manner, the direction of transmitted ray $\bar{P}$ can be determined by consulting Snell’s law. More specifically, $\bar{R}$ and $\bar{P}$ are functions of $\bar{N}$ and $\bar{V}$ defined as follows:</p>

<p>$$
\begin{gather}
\bar{V}^{\prime} = \frac{\bar{V}}{\vert \bar{V} \cdot \bar{N} \vert}, <br>
\bar{R} = \bar{V}^{\prime} + 2 \bar{N}, <br>
\bar{P} = k_{f} (\bar{N} + \bar{V}^{\prime}) - \bar{N},
\end{gather}
$$</p>

<p>where $k_{f} = (k_{n}^{2} \vert \bar{V}^{\prime} \vert ^{2} - \vert \bar{V}^{\prime} + \bar{N} \vert^{2})^{-1/2}$ and $k_{n}$ is the index of refraction. Note that these equations assume that $\bar{V} \cdot \bar{N}$ is less than zero, thus the sign of $\bar{N}$ must be adusted so that it points to the side of the surface from the direction which the intersecting ray is coming from. Similarily, the index of refraction must be adjusted to account for the sign change. Furthermore, one can simply assume $T = 0$, total internal reflection is occured when $k_{f}$ becomes imaginary.</p>

<p>One intuition we can obtain from the proposed rule is that the higher $k_{d}$ and the smaller $k_{s}$ will make the surface look less glossy (i.e., matte). This is obvious since we are weighting the diffuse intensity more than that of specular reflection. At the same time, it is worth noting that this method does not use the specular exponent $n$ as Phong’s model did. Rather, it is based on the physical observation that it is microscopic mirror-like facets that contribute to the intensity of reflected light in a small region of surface. Of course, one may come up with an idea to consider such irregularity of surface in microscopic scale by introducing random perturbation to surface normals during computation. Considerably small variation will result in glossy surface, while large variation will spread out rays randomly making the surface exhibit diffuse behavior.</p>

<p>Let’s turn our attention to more complicated pheonomena - interreflection. The model we discussed until now is nothing but an approximation of light-surface interaction at a surface point. Then one might ask: <em>“What happens to the reflected or transmitted rays?”.</em> Answering this is the key to understanding <em>global illumination</em>, one of the core concepts of modern physically-based rendering techniques.</p>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig3.png">
</center>
<p><span class="caption text-muted">Figure 3. <b>Trajectory of light traveling various media</b>.</span></p>

<p>Imagine a scene having multiple objects and light sources. Let’s follow the journey of a light ray starting from one of light sources in the scene. Before reaching the viewer, this ray will bounce off from several surfaces, go through transparent medium, etc. This process can be modeled using well-known tree structure like the figure below.</p>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig3.png">
</center>
<p><span class="caption text-muted">Figure 4. <b>Tree representing the trajectory of ray reaching the viewer</b>.</span></p>

<p>More pricisely, the tree above shows how the ray reaching the viewer from point $A$ in figure 2 is composed of. As one can see in the figure 2, two rays from different directions $T_{1}$ and $S_{1}$ are merged at point $A$, and then go straight to the viewer. However, the ray coming from direction $S_{1}$ is actually the compound of two rays from two directions $S_{2}$ and $T_{2}$. In reality, one can <em>backtrace</em> the path of each ray capture by the camera by simply reversing the direction of incident, reflected, and transmitted rays computed in the model discussed earlier. When implemented in the form of algorithm, such procedure can be performed recursively, until meeting the termination condition (e.g., setting the upper bound for the number of recursion, ray travels to free space of nothing, etc).</p>

<p>Additionally, at each step of recursion, especially when computing $\bar{L}_{j}$ to determine the diffuse reflection, one can determine whether the point is being directly illuminated by lights by casting rays to every light source in the scene and check if there is something between the point and a light source. If so, it implies that the effect of $\bar{L}_{j}$ must be attenutaed.</p>

<h2 id="visible-surface-processor">Visible Surface Processor</h2>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig5.png">
</center>
<p><span class="caption text-muted">Figure 5. <b>Rendering an image by casting rays from each pixel lying on the image plane</b>.</span></p>

<p>As mentioned earlier, it is much more efficient to trace the rays backward from the viewer to sources, rather than forward tracing the photons emitted from light sources in the scene. This is obviously the desirable choice since only few rays will reach the viewer and contribute to the rendered image. Thus, repeating the earlier discussion, we do the following:</p>

<ol>
  <li>Cast a ray from the viewer through a pixel of final image.</li>
  <li>If a ray intersect a surface of an object in the scene, produce rays in the $\bar{R}$ and $\bar{P}$ direction. Note that it depends on the property of the surface. For example, if the object is not transparent at all, a ray to direction $\bar{P}$ should not be generated.</li>
  <li>Repeat 1 and 2 for all pixels, until none of generated ray intersect a surface in the scene.</li>
</ol>

<p>Since one cannot know whether a ray will run into an object or not until following the entire path, the traditional optimization methods such as clipping and back-face culling cannot be used in this scheme. Instead, we can reduce the computation by introducing the concept of bounding volume with which we can test whether the ray intersect an object in the scene quickly. For simplicity, this work first used spheres for rendering since it is easy to perform intersection test and a sphere itself can serve as its own bounding volume. For nonspherical objects, sophiscated intersection processors must be designed for better performance.</p>

<ul>
  <li>Polygonal surfaces: Solve for the point of intersection of the ray and the plane of the polygon and then check whether the point is on the interior of that polygon.</li>
  <li>Surface consists of bicubic patches: Generate bounding spheres for each patch. If a ray intersect the bounding sphere, subdivide (using the method called <em>Catmull-Clark subdivision</em>) the patch and create bounding spheres for each subpatch and perform the same test over and over again.</li>
</ul>

<p>Moreover, this visible surface algorithm is also able to perform anti-aliasing. In this work, a pixel is defined as the rectangular region whose corners are four sample points as in the figure below.</p>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig6.png">
</center>
<p><span class="caption text-muted">Figure 6. <b>A pixel defined as the region surrounded by four sample points</b>. Intensities computed at each sample are almost identical in the case illustrated above.</span></p>

<p>As shown in the figure above, if the intensities computed at the four corners have nearly equal values, and no small object lies in the region between them, there is no problem. The rendering algorithm may assume that the average of four values is a good approximation for the pixel intensity. However, how about this case?</p>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig6.png">
</center>
<p><span class="caption text-muted">Figure 7. <b>An example of inadequate sampling</b>. While three rays intersect the same surface thus yielding similar values, one sampling travels further resulting in dramatically different intensity value.</span></p>

<p>In such case, the algorithm will subdivide the sample square into more smaller regions and then start over again. This will repeat until the computer runs out of resolution or until the algorithm collects enough information for determining the pixel intensity. And the values from each subregions are weighted according to their area (similar to bilinear interpolation).</p>

<center>
    <img class="img-fluid" src="/assets/post-images/Whitted/fig6.png">
</center>
<p><span class="caption text-muted">Figure 8. <b>An example generated by using the method proposed in the paper</b>.</span></p>

<h1 id="conclusion">Conclusion</h1>
<p>This paper proposes an illumination model based on techniques suggested by Phong and Blinn. However, instead of adapting previous rendering scheme with little modification, this paper presents a new paradigm of rendering - ray tracing. With ray tracing, global illumination can be simulated realistically by tracing rays generated at each point of intersection while recording the intensities at the same time.</p>

<p>However, this work also needs some improvements:</p>

<ul>
  <li>Diffuse reflection from distributed light sources</li>
  <li>More realistic specular reflections from less glossy surfaces</li>
  <li><strong>Runs slowly</strong></li>
</ul>


        <hr>

        <div class="clearfix">

          
          <a class="btn btn-primary float-left" href="/2021/08/29/Perceiver.html" data-toggle="tooltip" data-placement="top" title="Summary of 'Perceiver: General Perception with Iterative Attention'">← Previous<span class="d-none d-md-inline">
              Post</span></a>
          
          

        </div>

      </div>
    </div>
  </div>


  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          <li class="list-inline-item">
            <a href="mailto:dreamy1534@kaist.ac.kr">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
          
          
          
        </ul>
        <p class="copyright text-muted">Copyright © Seungwoo Yoo 2023</p>
      </div>
    </div>
  </div>
</footer>


  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/scripts.js"></script>

<script src="/assets/scripts.js"></script>




  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-XXXXXXXXX-X');
</script>



</body>

</html>
